---
title: "Autocorrelation estimation of KiloSort4 data"
---

```{r Rmdsetup, echo=FALSE}
# Set max width of markdown code outputs
options(width = 10000)
```

The neurons package provides functions to run a dichotomized Gaussian (DG) analysis of spike autocorrelation on different kinds of data, including KiloSort4 output. (Kilosort4 is a Python package for extracting spike clusters from multi-channel probe recordings.) The aim of this DG analysis of autocorrelation is to estimate the network time constant of single auditory neurons in the left and right hemisphere of various genotypes of mice. Network time constants provide an estimate of recurrence. Specifically, a higher network time constant indicates that a neuron receives a larger number of projections back on itself. Intuitively, the longer into the future a spike *now* increases the probability of a spike *later*, the stronger the connections from that neuron back onto itself must be. 

<h1>Setup</h1>

Begin by clearing the workspace, setting a random-number generator seed, and loading the neurons package.

```{r Rsetup}
# Clear the R workspace to start fresh
rm(list = ls())

# Set seed for reproducibility
set.seed(12345) 

# Load neurons package
library(neurons) 
```

<h1>Load data</h1>

Provide the file path to the output from kilosort4.

```{r datapath}
# Set path to data 
demo_data <- "/Users/michaelbarkasi/Library/CloudStorage/OneDrive-WashingtonUniversityinSt.Louis/projects_Oviedo_lab/_lateralized_recurrent_pathways/dichot-gaussian/data_demo"
```

The function **preprocess.kilo4** is used to process the kilosort4 output. This function expects its argument **data_path** to point to a folder the subfolders of which each contain a single kilosort4 output. This output should be in its own folder **kilosort4**. The following four files are needed, although others from kilosort4 can be in the directory as well:

- **spike_positions.npy**: 2D array giving the x and y position of each spike  
- **spike_clusters.npy**: integer giving the cluster number of each spike  
- **spike_times.npy**: sample number the spike occurred at  
- **cluster_group.tsv** or **cluster_KSLabel.tsv** or **cluster_info.tsv**: 2D array giving status of each cluster (0=noise, 1=MUA, 2=Good, 3=unsorted)

In addition, a MATLAB file **includeVector.mat** giving whether each cluster is stimulus-responisve (1) or not (0) should be included in the kilosort4 folder. Finally, along with the kilosort4 subfolder, there should be a file **StimulusStamps.csv** in each recording folder. 

<div class="figure">
  <img src="fig_folderstructure.png" alt="Image showing folder structure necessary for <b>preprocess.kilo4</b> function." width="90%">
  <p class="caption">Folder structure necessary for <b>preprocess.kilo4</b> function.</p>
</div>

Metadata about the recordings is needed to supply covariates. For this tutorial, a csv file with that data is in the neurons package itself. It can be loaded with the regular **read.csv** function in R. 

```{r load_metadata} 
# Load 
kilo4_metadata <- read.csv(
  system.file(
    "extdata", 
    "meta_data_kilo4demo.csv", 
    package = "neurons"
    )
  )

# Preview
print(head(kilo4_metadata))
```

The neurons package (as of v1.0) can only handle certain covariates, and expects them to have specific names (**type**, **genotype**, **sex**, **hemi**, **region**, **age**). The package also expects the data frame holding those covariates to have rows labeled with recording names that match the format of the recording names in the data. 

```{r reformat_metadata}
# Format and apply recording names to metadata as row names
rownames(kilo4_metadata) <- paste0(
  kilo4_metadata$DAY, 
  "_",
  kilo4_metadata$Neuralynx_ID
  )

# Keep only the relevant columns (covariates of interest)
kilo4_metadata <- kilo4_metadata[,c("HEMISPHERE","STRAIN","AGE","SEX")]

# Rename columns to match what's expected by neurons package 
colnames(kilo4_metadata) <- c("hemi", "genotype", "age", "sex")

# Preview 
print(head(kilo4_metadata))
```

<h1>Preprocess data into spike rasters</h1>

The function **preprocess.kilo4** converts cluster spike times into spike rasters of the standardized format expected by the neurons package. The recordings must be partitioned into trials, which **preprocess.kilo4** does with start and stop times relative to a stimulus. For example, information about responses to stimuli can be analyzed by setting the start time to something negative (before the stimulus) and the end time to something positive (after the stimulus). However, for estimating autocorrelation, it's the spontaneous activity during a period of silence after the stimulus which should be analyzed. In this case, the start time should be some time after the stimulus (to allow for settling) and the end time some time later. 

```{r preprocess_kilosort4_data}
spike.rasters.kilo4 <- preprocess.kilo4(
  trial_time_start = 500,      # ms
  trial_time_end = 500 + 1520, # ms
  recording.folder = demo_data,
  meta_data = kilo4_metadata, 
  max_spikes = 1e4,
  min_spikes = 1e2,
  min_trials = 1e2,
  pure_trials_only = TRUE, 
  good_cells_only = TRUE,
  stim_responsive_only = TRUE,
  verbose = FALSE
) 
```

A path (such as **demo_data**) for the actual data must be passed to **preprocess.kilo4**. Metadata (such as **kilo4_metadata**) will usually be provided, but is not necessary for the function to run. If left out, the preprocessed output will simply lack information about covariates. 

In addition to the start and stop times and pointers to the data, **preprocess.kilo4** has three Boolean variables controlling the quality of clusters extracted for further analysis:

- **pure_trials_only**: include only trials which do not overlap with other trials (i.e., do not have a start time before the end time of any previous trials)?
- **good_cells_only**: include only spike clusters which passed hand curation?
- **stim_responsive_only**: include only spike clusters which are responsive to stimuli?

Three additional numeric variables are also useful for quality control: 

- **max_spikes**: maximum number of spikes a cell can have to be extracted
- **min_spikes**: minimum number of spikes a cell must have to be extracted
- **min_trials**: minimum number of trials a cell must have to be extracted

Finally, if **verbose** is set to TRUE, the function will print out information about the files it is finding and parsing. 


The output **spike.rasters.kilo4** is a list with three elements: **spikes**, **timeXtrial**, and **cluster.key**. The first element, **spikes**, is a data frame giving a sparse representation of the spike rasters from each recording. Each row is a spike, with columns giving information such as cell number, time, and genotype. Here are the first few rows of the **spikes** data frame:

```{r}
print(head(spike.rasters.kilo4$spikes))
```

The second element, **timeXtrial**, is a list of matrices, one per cell, with rows corresponding to time bins and columns to trials. Each entry is a binary indicator of whether the cell fired in that time bin during that trial. (No example shown here.)

The third element, **cluster.key**, is a data frame with rows representing cells and columns giving information such as cell number, genotype, and number of spikes. Here are the first few rows of the **cluster.key** data frame:

```{r}
print(head(spike.rasters.kilo4$cluster.key))
```

Important summary information can be pulled from the **cluster.key** data frame. For example, how many cells were included in the output?

```{r summary_info}
n_cells <- nrow(spike.rasters.kilo4$cluster.key)
cat("Number of cells included:", n_cells)
```

The number of cells and summary statistics such as mean spike and trial count per covariate combination can be pulled as well: (Age left off for simplicity.)

```{r summary_info_advanced}
# Get all combinations of covariates
covariate_combos <- expand.grid(
  genotype = unique(spike.rasters.kilo4$cluster.key$genotype),
  hemi = unique(spike.rasters.kilo4$cluster.key$hemi),
  sex = unique(spike.rasters.kilo4$cluster.key$sex)
)

# Initialize variables to hold summary stats
n_cells <- rep(NA, nrow(covariate_combos))
mean_spikes <- rep(NA, nrow(covariate_combos))
mean_trials <- rep(NA, nrow(covariate_combos))

# Loop through combinations and get summary stats
for (cv in 1:nrow(covariate_combos)) {
  # Get combination of covariates
  combo <- covariate_combos[cv, ]
  
  # Subset cluster.key for this combination
  subset_key <- spike.rasters.kilo4$cluster.key[
    spike.rasters.kilo4$cluster.key$genotype == combo$genotype &
    spike.rasters.kilo4$cluster.key$hemi == combo$hemi &
    spike.rasters.kilo4$cluster.key$sex == combo$sex, 
  ]
  
  # If any cells in this combination, compute and save stats
  if (nrow(subset_key) > 0) {
    n_cells[cv] <- nrow(subset_key)
    mean_spikes[cv] <- round(mean(subset_key$num.of.spikes),1)
    mean_trials[cv] <- round(mean(subset_key$num.of.responsive.trials),1)
  }
}

# Print results 
print(data.frame(covariate_combos, n_cells, mean_spikes, mean_trials))
```

As can be seen, the above call to **preprocess.kilo4** used strict quality control criteria, resulting in few cells being extracted and most covariate combinations being either empty or having only one cell. For comparison, let's relax the criteria by allowing clusters which are not stimulus-responsive. Limiting to stimulus-responsive cells guarantees that the cells are auditory, but also excludes many cells.

<h1>Making neurons</h1>

With the kilosort4 data preprocessed into spike rasters, the next step is to convert these rasters into a special class of object from the neuron package, **neuron**. Let's convert both the strict and relaxed versions of the spike rasters.

```{r create_neuron_objects}
neurons.kilo4 <- load.rasters.as.neurons(
  spike.rasters.kilo4$spikes, 
  sample_rt = 1e3
  )
```

We want to load the spike rasters as **neuron**s because **neurons**s come with built-in methods for plotting rasters, plotting autocorrelation, and estimating autocorrelation parameters with dichotomized Gaussian simulations. 

For example, here is the raster from one cell:

```{r plot_raster}
example_cell_num <- 1
example_raster1 <- plot.raster(neurons.kilo4[[example_cell_num]]) + ggplot2::theme(
  panel.background = ggplot2::element_rect(fill = "white", colour = NA),
  plot.background  = ggplot2::element_rect(fill = "white", colour = NA)
)
print(example_raster1)
```

<h1>Estimate autocorrelation parameters</h1>


```{r plot_autocor}
# Compute autocorrelation for example cell
neurons.kilo4[[example_cell_num]]$compute_autocorrelation("sum")

# Fit exponential decay model to autocorrelation to estimate the network time constant (tau)
neurons.kilo4[[example_cell_num]]$set_edf_initials(0.001, 1.0)
neurons.kilo4[[example_cell_num]]$set_edf_termination(1e-8, 1000)
neurons.kilo4[[example_cell_num]]$fit_autocorrelation()

# Fetch and print estimated exponential decay parameters
print(neurons.kilo4[[example_cell_num]]$fetch_EDF_parameters())

# Plot computed autocorrelation and fitted exponential decay
example_autocor1 <- plot.autocorrelation(neurons.kilo4[[example_cell_num]]) + ggplot2::theme(
  panel.background = ggplot2::element_rect(fill = "white", colour = NA),
  plot.background  = ggplot2::element_rect(fill = "white", colour = NA)
)
print(example_autocor1)
```

The code above computes autocorrelation for one cell in a series of steps. The neurons package provides a function, **process.autocorr**, which does all of these steps in one call for a list of neurons.

```{r process_autocorr_as_batch}
autocor.results.batch <- process.autocorr(neurons.kilo4)
print(head(autocor.results.batch))
```

```{r estimate_autocorr}
# ... set number of sims to run per neuron
n_sims <- 100
# ... set number of trials to simulate per neuron
n_trials <- 500
# ... run estimates on data
autocor.ests.kilo4 <- estimate.autocorr.params(
  neuron_list = neurons.kilo4,
  n_trials_per_sim = n_trials, 
  n_sims_per_neurons = n_sims, 
  bin_count_action = "sum",
  A0 = 0.001,
  tau0 = 1.0,
  ctol = 1e-8,
  max_evals = 500,
  verbose = FALSE
  )
```

Run analysis: 

```{r stat_analysis}
autocorr_results <- analyze.autocorr(
  autocor.ests.kilo4,
  covariate = c("hemi","genotype"),
  n_bs = 1e4
)

df <- data.frame(
  value = unlist(autocorr_results, use.names = FALSE),
  group = rep(names(autocorr_results), each = nrow(autocorr_results))
)

# Plot
title_size <- 20 
axis_size <- 12 
legend_size <- 10
example_stats1 <- ggplot2::ggplot(df, ggplot2::aes(x = value, fill = group)) +
  ggplot2::geom_density(alpha = 0.6) +
  #scale_y_continuous(transform = "log1p") +
  ggplot2::labs(title = "Expected Time Constant", x = "ms", y = "Density") +
  ggplot2::theme_minimal() + 
  ggplot2::theme(
    plot.title = ggplot2::element_text(hjust = 0.5, size = title_size),
    axis.title = ggplot2::element_text(size = axis_size),
    axis.text = ggplot2::element_text(size = axis_size),
    legend.title = ggplot2::element_text(size = legend_size),
    legend.text = ggplot2::element_text(size = legend_size),
    legend.position = "bottom"
  ) + ggplot2::theme(
  panel.background = ggplot2::element_rect(fill = "white", colour = NA),
  plot.background  = ggplot2::element_rect(fill = "white", colour = NA)
)

print(example_stats1)
```